# 一、报错位置定位
## 1.1根据功能号判断日志位置
>+ k211，处理APP：statment_d
>+ K216，处理APP：accounts
>+ 其余K2开头的功能号，处理APP：dimple
>+ K11，处理APP：statement
>+ K1、K3，处理APP：spdeal
>+ K014，处理APP：controller
>+ K002，处理APP：flow
>+ K001、K015、K003，处理APP：frawwork
>+ P开头功能号，处理APP：transfer、webAdapter
>+ 下载、导出功能处理APP：download
## 1.2规范错误码
### 1.2.1编写错误码-错误信息字典
|  序号 | 错误码 | 错误信息 | 说明 |
| ---- | ---- | ---- | ----|
| 1 | 00000000 | 成功 | 请求成功 |
| 2 | 00000001 | 失败 | 请求失败 |
| 3 | 30000000 | （后台）查询失败 | 后台App返回错误信息 |
| 4 | 80000000 | （外调）无可用连接 | 外围系统返回错误信息 |
### 1.2.2设计错误类型
>+ 错误码0开头代表系统错误
>>+ 错误码3开头代表业务错误信息
>+ 错误码8开头代表调用外围系统错误
>+ ...等等
## 1.3现有日志逻辑
>+ GP2现有请求中，有请求流水字段：AjaxRequest.ｎ
>+ 可根据流水号追踪请求链路
## 1.4去掉angel中的错误码转换
# 二、关键位置输出日志信息
## 2.1基本的Logger编码规范
>1. 在一个对象中通常只使用一个Logger对象，Logger应该是static final的，只有在少数需要在构造函数中传递logger的情况下才使用private final。
>2. 输出Exceptions的全部Throwable信息，因为logger.error(msg)和logger.error(msg,e.getMessage())这样的日志输出方法会丢失掉最重要的StackTrace信息。
>3. 不允许记录日志后又抛出异常，因为这样会多次记录日志，只允许记录一次日志。
>4. 不允许出现System print(包括System.out.println和System.error.println)语句。
>5. 不允许出现printStackTrace。
>6. 日志性能的考虑，如果代码为核心代码，执行频率非常高，则输出日志建议增加判断，尤其是低级别的输出<debug、info、warn>。
>7. 有意义的日志
通常情况下在程序日志里记录一些比较有意义的状态数据：程序启动，退出的时间点；程序运行消耗时间；耗时程序的执行进度；重要变量的状态变化。除此之外，在公共的日志里规避打印程序的调试或者提示信息。
>8. 对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方式。
>9. 避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。
# 三、捕捉数据库异常信息
问题：锁表导致请求超时，后台无日志打印